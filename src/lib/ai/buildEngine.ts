import fs from "fs/promises";
import { prisma } from "@/lib/db";
import { callCodex } from "@/lib/ai/codex";
import { parseCodexBundle } from "@/lib/ai/parse";
import { buildCodexPrompt } from "@/lib/ai/prompt";
import { appendBuildLog } from "@/lib/ai/logs";
import { getWorkspacePaths } from "@/lib/ai/paths";
import { buildManifest, ensureEnvFiles, writeFileBundle } from "@/lib/ai/workspace";
import { startPreview } from "@/lib/ai/preview";
import type { BuildConfig } from "@/lib/ai/types";

export async function runBuildPipeline(buildId: string, config: BuildConfig, userPrompt: string) {
  const paths = getWorkspacePaths(buildId);
  await fs.mkdir(paths.repo, { recursive: true });

  try {
    await prisma.build.update({
      where: { id: buildId },
      data: { status: "building" },
    });

    await appendBuildLog(buildId, "Designing architecture");
    const prompt = buildCodexPrompt(config, userPrompt);

    await appendBuildLog(buildId, "Generating files via Codex");
    const output = await callCodex(prompt);
    const files = parseCodexBundle(output);

    await appendBuildLog(buildId, `Writing ${files.length} files`);
    await writeFileBundle(paths.repo, files);

    await appendBuildLog(buildId, "Ensuring .env + .env.example");
    const envVars = await ensureEnvFiles(paths.repo);

    await appendBuildLog(buildId, "Generating build manifest");
    await buildManifest(paths.root, paths.repo);

    const readmePath = `${paths.repo}/README.md`;
    const readmeExists = await fs
      .access(readmePath)
      .then(() => true)
      .catch(() => false);
    if (!readmeExists) {
      await fs.writeFile(
        readmePath,
        `# ${config.appName}\n\nGenerated by Omega AI Builder.\n\n## Environment variables\n${envVars
          .map((v) => `- ${v}`)
          .join("\n")}\n`,
        "utf8"
      );
    }

    await appendBuildLog(buildId, "Build complete");
    await prisma.build.update({
      where: { id: buildId },
      data: { status: "built" },
    });

    await startPreview(buildId);
  } catch (error: any) {
    console.error("Build failed", error);
    await appendBuildLog(buildId, `Build failed: ${error?.message || "Unknown error"}`);
    await prisma.build.update({
      where: { id: buildId },
      data: { status: "failed" },
    });
    await refundCredits(buildId);
    throw error;
  }
}

async function refundCredits(buildId: string) {
  const build = await prisma.build.findUnique({ where: { id: buildId } });
  if (!build || build.creditsHeld <= 0) return;
  const subscription = await prisma.subscription.findFirst({
    where: { userId: build.userId, status: "active" },
    orderBy: { updatedAt: "desc" },
  });
  if (!subscription) return;

  await prisma.subscription.update({
    where: { id: subscription.id },
    data: { creditsRemaining: subscription.creditsRemaining + build.creditsHeld },
  });
  await prisma.creditLedger.create({
    data: {
      userId: build.userId,
      subscriptionId: subscription.id,
      type: "REFUND",
      amount: build.creditsHeld,
      reason: "build_failed",
      buildId: build.id,
    },
  });

  await prisma.build.update({
    where: { id: build.id },
    data: { creditsHeld: 0 },
  });
}
